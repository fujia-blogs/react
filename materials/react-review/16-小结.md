# 小结

## react17

1. React v17 的发布非比寻常，因为它没有增加任何面向开发者的新特性。但是，这个版本会使得 React 自身的升级变得更加容易。
   值得特别说明的是，React v17 作为后续版本的“基石”，它让不同版本的 React 相互嵌套变得更加容易。 —— React 官方

2. React 17 中没有新特性，这是由它的定位决定的。React 17 的定位是后续 18、19 等更新版本的“基石”，它是一个“承上启下”的版本，用官方的说法来说，“React v17 开启了 React 渐进式升级的新篇章”。

### 改变点

#### 新的 JSX 转换逻辑

1. React 17 允许我们在不引入 React 的情况下直接使用 JSX，编译器会自动帮我们引入 JSX 的解析器。

#### 事件系统的重构

1. 两个方面：

- 卸掉历史包袱
- 拥抱新的潮流

2. 卸掉历史包袱：放弃利用 document 来做事件的中心化管控

> react17 之前，react 会通过将所有事件冒泡到 document 来实现对事件的中心化管控

- document 是整个文档树的根节点，操作 document 带来的影响范围实在是太大了，这将会使事情变得更加不可控。
- document 是一个全局概念，而组件只是全局的一个部分。

3. 拥抱新的潮流：**放弃事件池**

在 React 17 之前，合成事件对象会被放进一个叫作“事件池”的地方统一管理。这样做的目的是能够实现事件对象的复用，进而提高性能：每当事件处理函数执行完毕后，其对应的合成事件对象内部的所有属性都会被置空，意在为下一次被复用做准备。这也就意味着事件逻辑一旦执行完毕，我们就拿不到事件对象了。

```js
function handleChange(e) {
  // This won't work because the event object gets reused.
  setTimeout(() => {
    console.log(e.target.value); // too late
  }, 100);
}
```

要想拿到目标事件对象，必须显式地告诉 React——我永远需要它，也就是调用 e.persist() 函数，像下面这样：

```js
function handleChange(e) {
  e.persist();
  // This won't work because the event object gets reused.
  setTimeout(() => {
    console.log(e.target.value); // too late
  }, 100);
}
```

**React 17 拥抱了新时代的潮流，重新在研发体验和向下兼容性能之间做了选择，这一次，它选择了前者——放弃事件池，为每一个合成事件创建新的对象。**

#### Lane 模型的引入

1. react16 中处理优先级采用的是 expirationTime 模型

expirationTime 模型使用 expirationTime(一个时间长度)来描述任务的优先级；Lane 模型则使用二进制来表达任务的优先级

2. Lane 模型：通过将不同优先级赋值给一个位，通过 31 位的位运算来操作优先级。

**Lane 模型提供了一个新的优先级排序的思路，相对于 expirationTime 来说，它对优先级的处理会更细腻，能够覆盖更多的边界条件**

## 如何深入了解一个前端框架？

### 不要小看官方文档

1. React 文档在前端框架文档中属于相当优秀的范本，如果你懂得利用文档，会发现它不只是一个 API 手册或是入门教程，而是一套成体系的官方教学。

2. 在日常的源码阅读包括生产实践中，如果遇到了 React 相关的问题，请不要急于去阅读参差不齐的社区文章——先问问 React 文档试试看吧，或许你能收获的会比你想象中要多。

### 调用栈就是的你的学习地图

1. 在阅读源码之前，框架的函数调用栈将会给你指明许多方向性的问题。

比如当你想要了解 Hooks，那么就可以尝试去观察不同 Hooks 调用所触发的函数调用栈，从中找出出镜率最高的那些函数，它们大概率暗示着 Hooks 源码的主流程。事件系统、render 过程之类的也是同理。观察调用栈，寻找共性，然后点对点去阅读关键函数的源码，这将大大降低我们阅读源码的难度。

### 如何阅读源码？

1. 当你理解了一部分核心功能的源码逻辑之后，难免会对整个框架的运行机制产生好奇。这时候直接从入口文件出发去阅读所有的源码，仍然是一个不太明智的选择。

2. 在整体阅读源码之前，我们最好去复习一下框架官方对框架架构设计、源码分层相关的介绍——这些信息未必会全部暴露在文档里，但借助搜索引擎，我们总能找到一些线索——比如框架作者/官方团队的博文，其内容的权威度基本和文档持平。

3. 在理解了整个框架项目的架构分层之后，我们阅读源码的姿势就可以多样化一些了：可以尝试分层阅读，一次搞清楚一个大问题，最后再把整个思路按照架构分层的逻辑组合起来；也可以继续借助调用栈，通过观察一个完整的执行流程（比如 React 的首屏渲染过程）中所涉及的函数，自行将每个层次的逻辑对号入座，然后再向下拆分。

## 要点

1. 好的框架或“轮子”，追求的一定都是简单和稳定。

2. 经过几年的角逐和沉淀，主流前端框架的稳定性逐渐在强化，三大框架都向着 Web Components 的标准演化，一切并非倾向于无序，而是变得越来越确定、越来越可预测。

3. ，很多时候若你能深入地吃透一个优秀的框架，就能够迅速地积累许多可以复用的理解经验，这将为你学习其他的新知识创造极大的加速度。
